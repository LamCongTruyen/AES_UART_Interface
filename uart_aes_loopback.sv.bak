//==================================================================================//
// UART_AES_LOOPBACK – DUAL FIFO (128-bit RX + 8-bit TX) + AES-CTR
// Dữ liệu đến liên tục → không mất, không nghẽn
// Dùng always_ff tuần tự, dễ đọc, dễ debug
//==================================================================================//
module uart_aes_loopback (
    input  wire  clk,
    input  wire  rst_n,
    input  wire  rx,
    input  wire [127:0] key,
    input  wire [127:0] nonce,
    output wire  tx
);

    // =============================================================================
    // PARAMETERS
    // =============================================================================
    localparam RX_BLOCK_SIZE  = 16;     // 16 byte = 128 bit
    localparam TX_FIFO_DEPTH  = 64;     // 64 byte buffer
    localparam DATA_WIDTH     = 8;

    // =============================================================================
    // INTERNAL SIGNALS
    // =============================================================================
    // UART RX
    wire [7:0] rx_data;
    wire       rx_valid;

    // AES
    reg        aes_enable;
    reg [127:0] aes_plaintext;
    wire [127:0] ciphertext;
    wire        aes_valid_out;

    // RX: Gom 16 byte → 128 bit
    reg [127:0] rx_block_reg;
    reg [3:0]   rx_byte_count;      // 0 to 15
    reg         rx_block_ready;     // 1 khi đủ 128 bit

    // TX FIFO (8-bit)
    reg [7:0]  tx_fifo [0:TX_FIFO_DEPTH-1];
    reg [5:0]  tx_wr_ptr, tx_rd_ptr;
    reg [6:0]  tx_count;            // 0 to 64
    wire       tx_fifo_not_empty;
    reg        tx_trigger;
    wire       tx_busy;

    // TX UART
    reg [7:0]  tx_data;

    // =============================================================================
    // 1. UART RX INSTANCE
    // =============================================================================
    uart_rx uart_rx_inst (
        .clk(clk),
        .rst_n(rst_n),
        .rx(rx),
        .data_out(rx_data),
        .valid(rx_valid)
    );

    // =============================================================================
    // 2. AES-CTR INSTANCE
    // =============================================================================
    AES_CTR_pipelined u_aes (
        .clk(clk),
        .reset(~rst_n),
        .enable(aes_enable),
        .key(key),
        .nonce(nonce),
        .plaintext(aes_plaintext),
        .ciphertext(ciphertext),
        .valid_out(aes_valid_out)
    );

    // =============================================================================
    // 3. UART TX INSTANCE
    // =============================================================================
    uart_tx uart_tx_inst (
        .clk(clk),
        .rst_n(rst_n),
        .trigger(tx_trigger),
        .data_in(tx_data),
        .tx(tx),
        .busy(tx_busy)
    );

    // =============================================================================
    // 4. RX: Gom 16 byte thành 128-bit block (always_ff)
    // =============================================================================
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_block_reg    <= 128'h0;
            rx_byte_count   <= 4'd0;
            rx_block_ready  <= 1'b0;
        end else begin
            rx_block_ready <= 1'b0;  // default: pulse 1 chu kỳ

            if (rx_valid) begin
                // Dịch trái 8 bit, chèn byte mới vào cuối
                rx_block_reg <= {rx_block_reg[119:0], rx_data};
                rx_byte_count <= rx_byte_count + 1;

                if (rx_byte_count == 4'd15) begin
                    rx_block_ready <= 1'b1;         // Đủ 16 byte → báo AES
                    rx_byte_count  <= 4'd0;         // Reset đếm
                end
            end
        end
    end

    // =============================================================================
    // 5. AES CONTROL + TX FIFO WRITE (always_ff)
    // =============================================================================
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            aes_enable     <= 1'b0;
            aes_plaintext  <= 128'h0;
            tx_wr_ptr      <= 6'd0;
            tx_count       <= 7'd0;
        end else begin
            aes_enable <= 1'b0;  // pulse 1 chu kỳ

            // Khi có block đầy → kích AES
            if (rx_block_ready) begin
                aes_plaintext <= {rx_block_reg[119:0], rx_data}; // block cuối cùng
                aes_enable    <= 1'b1;
            end

            // Khi AES xong → ghi 16 byte vào TX FIFO
            if (aes_valid_out && tx_count <= TX_FIFO_DEPTH - 16) begin
                for (integer i = 0; i < 16; i++) begin
                    tx_fifo[tx_wr_ptr + i] <= ciphertext[127 - 8*i -: 8];
                end
                tx_wr_ptr <= tx_wr_ptr + 16;
                tx_count  <= tx_count + 16;
            end
        end
    end

    // =============================================================================
    // 6. TX FIFO READ + UART TX TRIGGER (always_ff)
    // =============================================================================
    assign tx_fifo_not_empty = (tx_count > 0);

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tx_rd_ptr   <= 6'd0;
            tx_trigger  <= 1'b0;
            tx_data     <= 8'h00;
            tx_count    <= 7'd0;
        end else begin
            tx_trigger <= 1'b0;  // default

            // Gửi khi: FIFO có dữ liệu + TX không bận + không đang trigger
            if (tx_fifo_not_empty && !tx_busy && !tx_trigger) begin
                tx_data    <= tx_fifo[tx_rd_ptr];
                tx_trigger <= 1'b1;
                tx_rd_ptr  <= (tx_rd_ptr == TX_FIFO_DEPTH-1) ? 0 : tx_rd_ptr + 1;
                tx_count   <= tx_count - 1;
            end
        end
    end

    // =============================================================================
    // 7. POINTER WRAP (an toàn)
    // =============================================================================
    // Đã xử lý trong điều kiện tăng pointer

endmodule