// Testbench for aes_uart_top module
`timescale 1ns / 1ps

module aes_uart_top_tb;

    // Parameters
    localparam CLK_PERIOD = 10; // 100 MHz clock
    localparam BAUD_RATE = 115200;
    localparam BIT_PERIOD = 5_000_000_000 / BAUD_RATE; // ns per bit

    // Signals
    logic         clk;
    logic         rst_n;
    logic         rx;
    logic         tx;

    // Instantiate the DUT
    uart_string_loopback dut (
        .clk(clk),
        .rst_n(rst_n),
        .rx(rx),
        .tx(tx)
    );

    // Clock generation
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end

    // Task to send a byte over UART RX
    task send_uart_byte;
        input [7:0] byte;
        begin
            // Start bit
            rx = 0;
            #BIT_PERIOD;
            // 8 data bits (LSB first)
            for (int i = 0; i < 8; i++) begin
                rx = byte[i];
                #BIT_PERIOD;
            end
            // Stop bit
            rx = 1;
            #BIT_PERIOD;
        end
    endtask

    // Task to receive a byte from UART TX
    task receive_uart_byte;
        output [7:0] byte;
        begin
            byte = 8'b0;
            // Wait for start bit
            @(negedge tx);
            #(BIT_PERIOD/2); // Sample at middle of bit
            // 8 data bits
            for (int i = 0; i < 8; i++) begin
                #BIT_PERIOD;
                byte[i] = tx;
            end
            // Stop bit
            #BIT_PERIOD;
            if (tx !== 1) $display("ERROR: Stop bit not high at time %t", $time);
        end
    endtask

    // Test stimulus
    initial begin
        // Initialize signals
        rst_n = 0;
        rx = 1; // UART idle state
        #100;

        // Release reset
        rst_n = 1;
        #100;

        // Send 16 bytes (128-bit plaintext) to RX
        $display("Sending plaintext to RX...");
        for (int i = 0; i < 16; i++) begin
            send_uart_byte(8'h11 + i); // Same pattern as original testbench
        end

        // Wait for AES processing (give enough time for pipeline)
        repeat (50) @(posedge clk);

        // Receive 16 bytes from TX
        $display("Receiving ciphertext from TX...");
        for (int i = 0; i < 16; i++) begin
            logic [7:0] received_byte;
            receive_uart_byte(received_byte);
            $display("Received byte %0d: %h at time %t", i, received_byte, $time);
        end

        // Wait and finish
        #1000;
        $display("Test completed at time %t", $time);
        $finish;
    end

    // Monitor TX for activity
    initial begin
        $monitor("Time=%t, TX=%b", $time, tx);
    end

endmodule