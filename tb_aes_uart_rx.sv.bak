`timescale 1ns / 1ps

module tb_aes_uart_rx;

    // ========================================
    // Tham số
    // ========================================
    localparam CLK_PERIOD = 20;           // 50 MHz → 20ns
    localparam BAUD_DIV   = 434;          // 50M / 115200 ≈ 434
    localparam TICK_DIV   = 27;           // 16x oversampling
    localparam BIT_TIME   = BAUD_DIV * TICK_DIV * CLK_PERIOD; // ~8680 ns

    // ========================================
    // Tín hiệu
    // ========================================
    logic clk;
    logic rst_n;
    logic rx;
    logic [127:0] ciphertext;
    logic         valid_out;

    // DUT
    aes_uart_rx_top dut (
        .clk(clk),
        .rst_n(rst_n),
        .rx(rx),
        .ciphertext(ciphertext),
        .valid_out(valid_out)
    );

    // ========================================
    // Tạo xung clock
    // ========================================
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end

    // ========================================
    // Tạo plaintext ngẫu nhiên
    // ========================================
    logic [127:0] test_plaintext;
    initial begin
        test_plaintext = $urandom();
        test_plaintext = {test_plaintext[127:8], 8'h00} | $urandom(); // Đảm bảo không trùng
        $display("\n=== TESTCASE: PLAINTEXT NGẪU NHIÊN ===");
        $display("Plaintext gửi: %032h", test_plaintext);
    end

    // ========================================
    // Task: Gửi 1 byte qua UART RX
    // ========================================
    task send_uart_byte(input [7:0] data);
        integer i;
        begin
            // Start bit (0)
            rx = 1'b0;
            #(BIT_TIME);

            // 8 data bits (LSB first)
            for (i = 0; i < 8; i++) begin
                rx = data[i];
                #(BIT_TIME);
            end

            // Stop bit (1)
            rx = 1'b1;
            #(BIT_TIME);
        end
    endtask

    // ========================================
    // Task: Gửi toàn bộ 16 byte plaintext
    // ========================================
    task send_plaintext();
        integer i;
        begin
            $display("\n=== GỬI 16 BYTE QUA UART RX ===");
            for (i = 0; i < 16; i++) begin
                send_uart_byte(test_plaintext[127 - i*8 -: 8]);
                $display("  Gửi byte %0d: %02h", i, test_plaintext[127 - i*8 -: 8]);
            end
        end
    endtask

    // ========================================
    // Kịch bản chính
    // ========================================
    initial begin
        // Reset
        rst_n = 0;
        rx    = 1;  // UART idle = 1
        #200;
        rst_n = 1;
        #200;

        // Gửi plaintext
        send_plaintext();

        // Chờ AES xử lý xong
        wait (valid_out == 1'b1);
        #100;

        // In kết quả
        $display("\n[ %0t ] AES HOÀN TẤT!", $time);
        $display("Plaintext  : %032h", test_plaintext);
        $display("Ciphertext : %032h", ciphertext);
        $display("Valid_out  : %b", valid_out);

        // Kết thúc
        #5000;
        $display("\n=== TESTBENCH HOÀN TẤT ===\n");
        $finish;
    end

    // ========================================
    // Monitor AES output
    // ========================================
    always @(posedge valid_out) begin
        $display("\n[%0t] AES VALID_OUT KÍCH HOẠT!", $time);
        $display("Ciphertext nhận được: %032h", ciphertext);
    end

    // ========================================
    // Theo dõi tín hiệu RX (debug)
    // ========================================
    initial begin
        $monitor("Time=%0t | RX=%b | State=%s", 
                 $time, rx, 
                 dut.uart_rx.state == 0 ? "IDLE" :
                 dut.uart_rx.state == 1 ? "START" :
                 dut.uart_rx.state == 2 ? "DATA" : "STOP");
    end

endmodule