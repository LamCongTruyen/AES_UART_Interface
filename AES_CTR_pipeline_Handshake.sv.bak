`timescale 1ns/1ps
module AES_CTR_pipeline_Handshake #(
    parameter LATENCY = 10  // Độ trễ pipeline AES
)(
    input  logic         clk,
    input  logic         reset,

    // Giao tiếp đầu vào
    input  logic [127:0] plaintext_in,
    input  logic         valid_in,
    output logic         ready_in,

    // Giao tiếp đầu ra
    output logic [127:0] ciphertext_out,
    output logic         valid_out,
    input  logic         ready_out,

    // AES control
    input  logic [127:0] key,
    input  logic [127:0] nonce
);

    // ========================
    //   Internal signals
    // ========================
    logic [127:0] counter;
    logic [127:0] keystream;
    logic [127:0] plaintext_delay [0:LATENCY];
    logic         valid_pipe [0:LATENCY];

    // ========================
    //   AES Pipeline (counter encryption)
    // ========================
    AES_pipeline_Encryption u_aes (
        .clk(clk),
        .reset(reset),
        .plaintext(counter),
        .key(key),
        .cypher(keystream)
    );

    // ========================
    //   Input handshake logic
    // ========================
    assign ready_in = 1'b1;  // luôn sẵn sàng nhận (có thể thêm FIFO nếu muốn)

    always_ff @(posedge clk or posedge reset) begin
        if (reset)
            counter <= 128'h0;
        else if (valid_in && ready_in)
            counter <= (counter == 128'h0) ? nonce : (counter + 1);
    end

    // ========================
    //   Delay plaintext theo pipeline
    // ========================
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            for (int i = 0; i <= LATENCY; i++)
                plaintext_delay[i] <= 0;
        end else begin
            plaintext_delay[0] <= plaintext_in;
            for (int i = 1; i <= LATENCY; i++)
                plaintext_delay[i] <= plaintext_delay[i-1];
        end
    end

    // ========================
    //   Delay valid signal
    // ========================
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            for (int i = 0; i <= LATENCY; i++)
                valid_pipe[i] <= 0;
        end else begin
            valid_pipe[0] <= valid_in && ready_in;
            for (int i = 1; i <= LATENCY; i++)
                valid_pipe[i] <= valid_pipe[i-1];
        end
    end

    // ========================
    //   Output: XOR plaintext & keystream
    // ========================
    logic [127:0] cipher_next;
    assign cipher_next = plaintext_delay[LATENCY] ^ keystream;

    // Giữ valid_out nếu ready_out chưa sẵn sàng
    logic [127:0] ciphertext_reg;
    logic         valid_reg;

    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            ciphertext_reg <= 0;
            valid_reg      <= 0;
        end else begin
            if (ready_out || !valid_reg) begin
                valid_reg      <= valid_pipe[LATENCY];
                ciphertext_reg <= cipher_next;
            end
        end
    end

    assign valid_out      = valid_reg;
    assign ciphertext_out = ciphertext_reg;

endmodule
